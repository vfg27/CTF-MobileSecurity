# Solution

## Description of the problem

The filebrowser challenge requires to inspect the contents of a builded apk to obtain information about the app, execute a custom app in the server and obtain the flag.

## Solution

First of all, I debugged the apk in Android Studio. Inside the app I obtained the resources, the manifest and the .dex files. In these files, I can see the bytecode of the classes in Smali. To facilitate me the work, I used an app (jadx) to translate the Smali code to Java code. There I found four activities: MainActivity, QueryActivity, AboutActivity and PluginActivity (this one has an intent filter with action "com.mobisec.browser.action.START_PLUGIN" and permission "com.mobisec.filebrowser.permission.PLUGIN"). Also I found a provider LogProvider. First, I checked the MainActivity. When it is created it generates a key of 20 characters that can be upper letters, lower letters or numbers, each time the MainActivity is created, a new key is generated at random, and it is stored in a preferences file called keys.xml. Then, the flag is set in a database via logQuery. The method getFlag() is inside the MainActivity. This method obtains an aesKey making the MD5 hash of the random key generated, retreives the flag from a database and decrypts it with this aesKey. In the LogProvider class I could check that the database is called "LogDb" and the table where the flag is stored is: " CREATE TABLE log (id INTEGER PRIMARY KEY AUTOINCREMENT,  oper TEXT NOT NULL,  arg TEXT NOT NULL);". The QueryActivity is used to perform actions in the system, more precisely, in the MainActivity there are three buttons, each one of them executes one action: ls, du or cat; with an argument passed as String. When clicked, that bash command is executed and it print the result. However, nowhere is checked that the argument doesnÂ´t contains ";" or "|" making possible the execution of multiple lines of code. The PluginActivity creates an Intent to QueryActivity and stores it in a PendingIntent, this pending Intent is sent back in an Intent under the flag "pi". The Intent inside the PendingIntent can be modified. If I manage to receive that PendingIntent I could send the Intents I wanted to QueryActivity as if they were sent by PluginActivity itself (with its permissions).
In order to obtain the flag, I decided to create a custom app in Android Studio. In that app I added the permissions: android.permission.WRITE_EXTERNAL_STORAGE, android.permission.READ_EXTERNAL_STORAGE and com.mobisec.filebrowser.permission.PLUGIN" android:protectionLevel="normal (the custom permission to send the Intent to PluginActivity, it also had to be defined in a Manifest class). Then, in the MainActivity I created an Intent to the PluginActivity and I receive the response with an ActivityResultLauncher. I extracted the PendingIntent from the Intent received and with it I sent a new Intent (the one that is going to QueryActivity) with the extras: ("oper","ls"), ("debug", true) and ("arg"," ; sqlite3 /data/data/com.mobisec.filebrowser/databases/LogDb \"SELECT * FROM log;\" > /sdcard/aux.log") to extract the contents of the database in a .log file in the sdcard (I found where the database was stored after installing the app inside my virtual device and checking its contents with AndroidStudio). Then I just had to read the .log file and print its contents after waiting a few seconds in order to wait for the extraction of the data. After checking the results I saw that the contents where divided by "|" and that they were numerated, so I splited the result in multiple strings (each one a different value from the database). In order to decrypt these contents I needed the aesKey so I launched another Intent to QueryActivity with the PendingIntent, but in this case with the extras: ("oper","ls"), ("debug", true) and 
	
	("arg"," ; awk -F'[<>]' '/<string name=\"key\">/{print $3}' /data/data/com.mobisec.filebrowser/shared_prefs/keys.xml > /sdcard/aux2.log")

After reading and hashing the contents of aux2.log I obtained the aesKey. Making the inverse process of decryption of the contents of the database with this key I obtained the flag: MOBISEC{a_good_file_browser_would_gimme_the_flag_with_no_hacks}.

## Optional Feedback

I think this challenge is very difficult. However, this time I found it really entertaining. The only thing I would say is that I had to change some methods from the original decryption because I got some problems with them and that made me loose a lot of time when I already had all I needed for obtaining the flag.